---
title: "Measures of Association for Vaccine Attitudes (2024 Voters)"
format: html
---

```{r setup}
#| echo: false
#| warning: false
#| message: false

# Load required packages and data
source("project-setup.R")
load_analysis_data()

# Filter to 2024 voters only
voters_2024 <- data |>
  filter(
    candidate_2024 %in% c("Kamala Harris", "Donald Trump", "Someone else")
  )

# Create survey design for 2024 voters
svy_2024 <- svydesign(
  ids = ~1,
  weights = ~WEIGHT_EN,
  data = voters_2024,
  na.action = na.pass  # Keep NAs for debugging
)

cat("Total 2024 voters:", nrow(voters_2024), "\n")
cat("Weighted N:", round(sum(voters_2024$WEIGHT_EN, na.rm = TRUE)), "\n\n")
```


## Clean All Variables

```{r clean_variables}
#| echo: false
#| warning: false
#| message: false

cat("=== CLEANING ALL VARIABLES ===\n\n")

# First, let's see what problematic values exist in outcome variables
cat("Checking outcome variables for problematic responses:\n")
cat("---------------------------------------------------\n")
cat("\nJHU5A values:\n")
print(table(voters_2024$JHU5A, useNA = "always"))

cat("\nJHU6C values:\n")
print(table(voters_2024$JHU6C, useNA = "always"))

# Clean all variables by removing Unknown/NA/Don't know/Refused/Skipped
voters_2024_clean <- voters_2024 |>
  mutate(
    # Clean age - remove "Under 18" and any NAs
    age_clean = case_when(
      !is.na(age_cat) & age_cat %in% c("18-29", "30-44", "45-59", "60+") ~ age_cat,
      TRUE ~ NA_character_
    ),

    # Clean gender - remove "Unknown" and any NAs
    gender_clean = case_when(
      !is.na(gender_cat) & gender_cat == "Male" ~ "Male",
      !is.na(gender_cat) & gender_cat == "Female" ~ "Female",
      !is.na(GENDER) & GENDER == "Male" & (is.na(gender_cat) | gender_cat == "Unknown") ~ "Male",
      !is.na(GENDER) & GENDER == "Female" & (is.na(gender_cat) | gender_cat == "Unknown") ~ "Female",
      TRUE ~ NA_character_
    ),

    # Clean education - use actual values from the data and check for NA
    education_clean = case_when(
      !is.na(education_cat) & education_cat %in% c("Less than high school",
                          "High school graduate or equivalent",
                          "Some college/associates degree",
                          "Bachelor's degree",
                          "Postgraduate study/professional degree") ~ education_cat,
      TRUE ~ NA_character_
    ),

    # Clean income - use actual values from the data and check for NA
    income_clean = case_when(
      !is.na(income_cat) & income_cat %in% c("Less than $30,000",
                        "$30,000 to under $60,000",
                        "$60,000 to under $100,000",
                        "$100,000 or more") ~ income_cat,
      TRUE ~ NA_character_
    ),

    # Clean race/ethnicity - use actual values from the data and check for NA
    race_eth_clean = case_when(
      !is.na(race_eth_cat) & race_eth_cat %in% c("White, non-Hispanic",
                          "Black, non-Hispanic",
                          "Hispanic",
                          "Asian-Pacific Islander, non-Hispanic",
                          "Other, non-Hispanic",
                          "2+, non-Hispanic") ~ race_eth_cat,
      TRUE ~ NA_character_
    ),

    # Clean JHU5A - remove DON'T KNOW, REFUSED, SKIPPED ON WEB and NAs
    JHU5A_clean = case_when(
      !is.na(JHU5A) & JHU5A %in% c("Strongly support", "Support", "Neither support nor oppose",
                   "Oppose", "Strongly oppose") ~ JHU5A,
      TRUE ~ NA_character_
    ),

    # Clean JHU6C - remove DON'T KNOW, REFUSED, SKIPPED ON WEB and NAs
    JHU6C_clean = case_when(
      !is.na(JHU6C) & JHU6C %in% c("Strongly support", "Support", "Neither support nor oppose",
                   "Oppose", "Strongly oppose") ~ JHU6C,
      TRUE ~ NA_character_
    )
  )

# Report cleaning results
cat("Variable cleaning results:\n")
cat("-------------------------\n\n")

vars_to_check <- list(
  "age" = c("age_cat", "age_clean"),
  "gender" = c("gender_cat", "gender_clean"),
  "education" = c("education_cat", "education_clean"),
  "income" = c("income_cat", "income_clean"),
  "race_eth" = c("race_eth_cat", "race_eth_clean"),
  "JHU5A" = c("JHU5A", "JHU5A_clean"),
  "JHU6C" = c("JHU6C", "JHU6C_clean")
)

for(var_name in names(vars_to_check)) {
  orig <- vars_to_check[[var_name]][1]
  clean <- vars_to_check[[var_name]][2]

  n_orig <- sum(!is.na(voters_2024_clean[[orig]]))
  n_clean <- sum(!is.na(voters_2024_clean[[clean]]))
  n_removed <- n_orig - n_clean

  cat(sprintf("%s: %d original -> %d clean (removed %d Unknown/invalid)\n",
              var_name, n_orig, n_clean, n_removed))
}

cat("\n\nCleaned variable distributions:\n")
cat("-------------------------------\n")
cat("Note: These show the distribution AFTER setting invalid responses to NA.\n")
cat("The Cram√©r's V calculation will exclude all NA rows.\n\n")

cat("Age (cleaned):\n")
age_table <- table(voters_2024_clean$age_clean)
print(age_table)
if(any(is.na(voters_2024_clean$age_clean))) {
  cat(sprintf("  [%d NA values will be excluded from calculations]\n", sum(is.na(voters_2024_clean$age_clean))))
}
cat("\n")

cat("Gender (cleaned):\n")
gender_table <- table(voters_2024_clean$gender_clean)
print(gender_table)
if(any(is.na(voters_2024_clean$gender_clean))) {
  cat(sprintf("  [%d NA values will be excluded from calculations]\n", sum(is.na(voters_2024_clean$gender_clean))))
}
cat("\n")

cat("Education (cleaned):\n")
edu_table <- table(voters_2024_clean$education_clean)
print(edu_table)
if(any(is.na(voters_2024_clean$education_clean))) {
  cat(sprintf("  [%d NA values will be excluded from calculations]\n", sum(is.na(voters_2024_clean$education_clean))))
}
cat("\n")

cat("Income (cleaned):\n")
income_table <- table(voters_2024_clean$income_clean)
print(income_table)
if(any(is.na(voters_2024_clean$income_clean))) {
  cat(sprintf("  [%d NA values will be excluded from calculations]\n", sum(is.na(voters_2024_clean$income_clean))))
}
cat("\n")

cat("Race/Ethnicity (cleaned):\n")
race_table <- table(voters_2024_clean$race_eth_clean)
print(race_table)
if(any(is.na(voters_2024_clean$race_eth_clean))) {
  cat(sprintf("  [%d NA values will be excluded from calculations]\n", sum(is.na(voters_2024_clean$race_eth_clean))))
}
cat("\n")

cat("JHU5A (cleaned - ONLY valid Likert responses):\n")
jhu5a_table <- table(voters_2024_clean$JHU5A_clean)
print(jhu5a_table)
if(any(is.na(voters_2024_clean$JHU5A_clean))) {
  cat(sprintf("  [%d responses excluded (DON'T KNOW/REFUSED/SKIPPED/NA)]\n", sum(is.na(voters_2024_clean$JHU5A_clean))))
}
cat("\n")

cat("JHU6C (cleaned - ONLY valid Likert responses):\n")
jhu6c_table <- table(voters_2024_clean$JHU6C_clean)
print(jhu6c_table)
if(any(is.na(voters_2024_clean$JHU6C_clean))) {
  cat(sprintf("  [%d responses excluded (DON'T KNOW/REFUSED/SKIPPED/NA)]\n", sum(is.na(voters_2024_clean$JHU6C_clean))))
}
cat("\n")

# Update the main data frame
voters_2024 <- voters_2024_clean
```

## Association Measure Functions

```{r association_functions}
#| echo: false
#| warning: false
#| message: false

# Function to calculate weighted Somers' D using DescTools
calculate_somers_d <- function(x_var, y_var, svy_design, direction = "row") {
  # Load DescTools if not already loaded
  if (!require(DescTools, quietly = TRUE)) {
    stop("DescTools package is required for Somers' D calculation")
  }

  # Get the data with weights
  data <- svy_design$variables
  weights <- weights(svy_design)

  # Get the variables
  x <- data[[x_var]]
  y <- data[[y_var]]

  # Remove missing values
  complete_idx <- complete.cases(x, y)
  x <- x[complete_idx]
  y <- y[complete_idx]
  w <- weights[complete_idx]

  # Ensure variables are ordered factors
  if (!is.ordered(x)) x <- as.ordered(x)
  if (!is.ordered(y)) y <- as.ordered(y)

  # Calculate Somers' D using DescTools
  # SomersDelta returns D with confidence intervals
  if (direction == "row") {
    # D_yx: Y dependent on X (demographics predict attitudes)
    result <- tryCatch({
      DescTools::SomersDelta(x, y, weights = w, direction = "row",
                            conf.level = 0.95)
    }, error = function(e) {
      # Fallback to manual calculation if DescTools fails
      return(calculate_somers_d_manual(x, y, w, direction = "row"))
    })
  } else {
    result <- tryCatch({
      DescTools::SomersDelta(x, y, weights = w, direction = "column",
                            conf.level = 0.95)
    }, error = function(e) {
      return(calculate_somers_d_manual(x, y, w, direction = "column"))
    })
  }

  # Extract values and calculate p-value from CI
  if (is.numeric(result) && length(result) >= 3) {
    somers_d <- result[1]
    ci_lower <- result[2]
    ci_upper <- result[3]

    # Calculate SE from CI (assuming normal approximation)
    se <- (ci_upper - ci_lower) / (2 * 1.96)

    # Calculate p-value
    if (se > 0) {
      z_stat <- somers_d / se
      p_value <- 2 * (1 - pnorm(abs(z_stat)))
    } else {
      p_value <- NA
    }
  } else {
    # If result is not in expected format, return NAs
    somers_d <- NA
    p_value <- NA
    se <- NA
  }

  return(list(somers_d = somers_d, p_value = p_value, se = se))
}

# Fallback manual calculation function
calculate_somers_d_manual <- function(x, y, weights, direction = "row") {
  # Create weighted contingency table
  tab <- xtabs(weights ~ x + y)
  tab <- as.matrix(tab)
  nr <- nrow(tab)
  nc <- ncol(tab)
  n <- sum(tab)

  # Calculate concordant and discordant pairs
  concordant <- 0
  discordant <- 0
  ties_y <- 0

  for (i in 1:nr) {
    for (j in 1:nc) {
      for (ii in 1:nr) {
        for (jj in 1:nc) {
          if (i < ii && j < jj) {
            concordant <- concordant + tab[i, j] * tab[ii, jj]
          } else if (i < ii && j > jj) {
            discordant <- discordant + tab[i, j] * tab[ii, jj]
          } else if (i != ii && j == jj) {
            ties_y <- ties_y + tab[i, j] * tab[ii, jj]
          }
        }
      }
    }
  }

  # Calculate Somers' D
  denominator <- concordant + discordant + ties_y
  if (denominator == 0) return(c(NA, NA, NA))

  somers_d <- (concordant - discordant) / denominator

  # Simple SE approximation
  se <- sqrt((1 - somers_d^2) / (n - 2))
  ci_lower <- somers_d - 1.96 * se
  ci_upper <- somers_d + 1.96 * se

  return(c(somers_d, ci_lower, ci_upper))
}

# Function to calculate weighted Cram√©r's V with detailed debugging
calculate_cramers_v_debug <- function(demographic_var, outcome_var, svy_design, verbose = TRUE) {

  if(verbose) {
    cat("\n================================================\n")
    cat(paste0("Calculating Cram√©r's V: ", demographic_var, " √ó ", outcome_var, "\n"))
    cat("================================================\n")
  }

  tryCatch({
    # Get the data
    data <- svy_design$variables

    # Check variables exist
    if(!demographic_var %in% names(data)) {
      return(list(
        cramers_v = NA,
        error = paste("Demographic variable not found:", demographic_var)
      ))
    }
    if(!outcome_var %in% names(data)) {
      return(list(
        cramers_v = NA,
        error = paste("Outcome variable not found:", outcome_var)
      ))
    }

    # Define valid responses for each variable type
    valid_likert <- c("Strongly support", "Support", "Neither support nor oppose",
                      "Oppose", "Strongly oppose")

    # Filter for valid responses ONLY
    # For outcome variables (JHU5A_clean, JHU6C_clean), check if they end with "_clean"
    # If so, they should already have NA for invalid responses
    # Otherwise, filter for valid Likert responses

    if(grepl("_clean$", outcome_var)) {
      # For cleaned variables, just remove NAs
      valid_idx <- !is.na(data[[demographic_var]]) & !is.na(data[[outcome_var]])
    } else if(outcome_var %in% c("JHU5A", "JHU6C")) {
      # For raw outcome variables, filter for valid responses only
      valid_idx <- !is.na(data[[demographic_var]]) &
                   data[[outcome_var]] %in% valid_likert
    } else {
      # For other variables, just check for non-NA
      valid_idx <- !is.na(data[[demographic_var]]) & !is.na(data[[outcome_var]])
    }

    # Similarly for demographic variables
    if(grepl("_clean$", demographic_var)) {
      # Already cleaned, just ensure no NAs
      valid_idx <- valid_idx & !is.na(data[[demographic_var]])
    }

    n_valid <- sum(valid_idx)

    if(verbose) {
      cat(paste0("Valid cases (excluding DON'T KNOW/REFUSED/SKIPPED/NA): ", n_valid, " out of ", nrow(data), "\n"))
    }

    if(n_valid < 20) {
      return(list(
        cramers_v = NA,
        error = paste("Insufficient valid cases:", n_valid)
      ))
    }

    # Create subset with valid cases only
    data_complete <- data[valid_idx, ]

    # Convert to factors and drop unused levels (including NA)
    data_complete[[demographic_var]] <- droplevels(as.factor(data_complete[[demographic_var]]))
    data_complete[[outcome_var]] <- droplevels(as.factor(data_complete[[outcome_var]]))

    # Check unique values
    n_demo_levels <- length(levels(data_complete[[demographic_var]]))
    n_outcome_levels <- length(levels(data_complete[[outcome_var]]))

    if(verbose) {
      cat(paste0("Demographic levels: ", n_demo_levels, "\n"))
      cat(paste0("Outcome levels: ", n_outcome_levels, "\n"))
    }

    # Create new survey design with complete cases
    svy_complete <- svydesign(
      ids = ~1,
      weights = as.formula(paste0("~", names(data)[which(names(data) == "WEIGHT_EN")])),
      data = data_complete,
      na.action = na.omit
    )

    # Create formula
    formula <- as.formula(paste0("~", demographic_var, "+", outcome_var))

    # Calculate chi-square
    if(verbose) cat("Calculating chi-square test...\n")

    chisq_result <- svychisq(formula, design = svy_complete, statistic = "Chisq")

    # Extract statistics
    chi_sq <- as.numeric(chisq_result$statistic)
    p_value <- chisq_result$p.value

    if(verbose) {
      cat(paste0("Chi-square: ", round(chi_sq, 3), "\n"))
      cat(paste0("p-value: ", round(p_value, 4), "\n"))
    }

    # Get weighted N
    n_weighted <- sum(weights(svy_complete))

    # Get table dimensions
    tab <- svytable(formula, design = svy_complete)
    r <- nrow(tab)
    c <- ncol(tab)

    # Calculate Cram√©r's V
    k <- min(r-1, c-1)
    cramers_v <- sqrt(chi_sq / (n_weighted * k))

    if(verbose) {
      cat(paste0("Cram√©r's V: ", round(cramers_v, 3), "\n"))
      cat(paste0("Table size: ", r, "√ó", c, "\n"))
    }

    # Interpretation
    interpretation <- case_when(
      cramers_v < 0.1 ~ "Negligible",
      cramers_v < 0.2 ~ "Weak",
      cramers_v < 0.3 ~ "Moderate",
      TRUE ~ "Strong"
    )

    return(list(
      cramers_v = cramers_v,
      chi_sq = chi_sq,
      p_value = p_value,
      n = n_valid,
      n_weighted = n_weighted,
      table_dims = paste0(r, "√ó", c),
      interpretation = interpretation,
      error = NA
    ))

  }, error = function(e) {
    if(verbose) {
      cat(paste0("ERROR: ", e$message, "\n"))
    }
    return(list(
      cramers_v = NA,
      error = e$message
    ))
  })
}
```

## Calculate Cram√©r's V

```{r calculate_cramers_v}
#| echo: false
#| warning: false
#| message: false

# Update survey design with cleaned data
svy_clean <- svydesign(
  ids = ~1,
  weights = ~WEIGHT_EN,
  data = voters_2024,
  na.action = na.pass
)

# Test with cleaned categories (no Unknown/invalid values)
demographics_to_test <- list(
  "Age" = "age_clean",
  "Gender" = "gender_clean",
  "Education" = "education_clean",
  "Income" = "income_clean",
  "Race/Ethnicity" = "race_eth_clean"
)

outcomes_to_test <- list(
  "Support Gov't Vaccines (JHU5A)" = "JHU5A_clean",
  "Remove School Requirements (JHU6C)" = "JHU6C_clean"
)

results_no_collapse <- list()

for(demo_name in names(demographics_to_test)) {
  for(outcome_name in names(outcomes_to_test)) {
    demo_var <- demographics_to_test[[demo_name]]
    outcome_var <- outcomes_to_test[[outcome_name]]

    result <- calculate_cramers_v_debug(demo_var, outcome_var, svy_clean, verbose = FALSE)

    results_no_collapse[[paste0(demo_name, " √ó ", outcome_name)]] <- result
  }
}
```

## Calculate Somers' D for Ordinal Variables

```{r calculate_somers_d}
#| echo: false
#| warning: false
#| message: false

# Create ordered factors for ordinal variables
voters_2024_ordered <- voters_2024 |>
  mutate(
    # Ordered demographics
    age_ordered = factor(age_clean,
                        levels = c("18-29", "30-44", "45-59", "60+"),
                        ordered = TRUE),
    education_ordered = factor(education_clean,
                              levels = c("Less than high school",
                                       "High school graduate or equivalent",
                                       "Some college/associates degree",
                                       "Bachelor's degree",
                                       "Postgraduate study/professional degree"),
                              ordered = TRUE),
    income_ordered = factor(income_clean,
                           levels = c("Less than $30,000",
                                    "$30,000 to under $60,000",
                                    "$60,000 to under $100,000",
                                    "$100,000 or more"),
                           ordered = TRUE),
    # Ordered outcomes - NOTE: "Strongly oppose" to "Strongly support"
    JHU5A_ordered = factor(JHU5A_clean,
                          levels = c("Strongly oppose", "Oppose",
                                   "Neither support nor oppose",
                                   "Support", "Strongly support"),
                          ordered = TRUE),
    JHU6C_ordered = factor(JHU6C_clean,
                          levels = c("Strongly oppose", "Oppose",
                                   "Neither support nor oppose",
                                   "Support", "Strongly support"),
                          ordered = TRUE)
  )

# Define ordinal demographics only
ordinal_demographics <- list(
  "Age" = "age_ordered",
  "Education" = "education_ordered",
  "Income" = "income_ordered"
)

outcomes_ordered <- list(
  "Support Gov't Vaccines (JHU5A)" = "JHU5A_ordered",
  "Remove School Requirements (JHU6C)" = "JHU6C_ordered"
)

# Store Somers' D results
results_somers <- list()

for(demo_name in names(ordinal_demographics)) {
  for(outcome_name in names(outcomes_ordered)) {
    demo_var <- ordinal_demographics[[demo_name]]
    outcome_var <- outcomes_ordered[[outcome_name]]

    # Filter to complete cases
    complete_idx <- !is.na(voters_2024_ordered[[demo_var]]) & !is.na(voters_2024_ordered[[outcome_var]])

    if(sum(complete_idx) >= 20) {
      svy_complete <- svydesign(
        ids = ~1,
        weights = ~WEIGHT_EN,
        data = voters_2024_ordered[complete_idx, ],
        na.action = na.omit
      )

      # Calculate Somers' D (Y dependent on X - demographics predict attitudes)
      somers_result <- calculate_somers_d(demo_var, outcome_var, svy_complete, direction = "row")

      results_somers[[paste0(demo_name, " √ó ", outcome_name)]] <- list(
        somers_d = somers_result$somers_d,
        p_value = somers_result$p_value,
        n = sum(complete_idx)
      )
    }
  }
}
```


## Summary of Results

```{r summary}
#| echo: false
#| warning: false
#| message: false

# Create clean summary table
summary_data <- data.frame(
  Association = names(results_no_collapse),
  `Cram√©r's V` = sapply(results_no_collapse, function(x) {
    if(is.na(x$cramers_v)) return("‚Äî")
    sprintf("%.3f", x$cramers_v)
  }),
  `p-value` = sapply(results_no_collapse, function(x) {
    if(is.null(x$p_value) || length(x$p_value) == 0 || is.na(x$p_value)) return("‚Äî")
    if(x$p_value < 0.001) return("<0.001")
    sprintf("%.3f", x$p_value)
  }),
  stringsAsFactors = FALSE
)

# Filter out failed calculations
summary_data <- summary_data[summary_data$`Cram√©r.s.V` != "‚Äî", ]

if(nrow(summary_data) > 0) {
  print(summary_data, row.names = FALSE)
}

# Save results
saveRDS(results_no_collapse, "output/cramers_v_cleaned.rds")
```

## Results Table: Cram√©r's V (All Variables)

```{r tables_cramers_v}
#| echo: false
#| warning: false
#| message: false
#| output: asis

library(kableExtra)

# Create Cram√©r's V comparison matrix
comparison_matrix <- data.frame(
  Demographic = unique(gsub(" √ó .*", "", names(results_no_collapse))),
  stringsAsFactors = FALSE
)

# Add columns for each question
for(q in c("Support Gov't Vaccines (JHU5A)", "Remove School Requirements (JHU6C)")) {
  comparison_matrix[[gsub(" \\(.*\\)", "", q)]] <- sapply(comparison_matrix$Demographic, function(d) {
    key <- paste0(d, " √ó ", q)
    if(key %in% names(results_no_collapse)) {
      result <- results_no_collapse[[key]]
      if(!is.na(result$cramers_v)) {
        cv_str <- sprintf("%.3f", result$cramers_v)
        if(!is.null(result$p_value) && !is.na(result$p_value)) {
          if(result$p_value < 0.001) cv_str <- paste0(cv_str, "***")
          else if(result$p_value < 0.01) cv_str <- paste0(cv_str, "**")
          else if(result$p_value < 0.05) cv_str <- paste0(cv_str, "*")
        }
        return(cv_str)
      }
    }
    return("‚Äî")
  })
}

matrix_display <- comparison_matrix |>
  kable(escape = FALSE, format = "html", row.names = FALSE) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)

print(matrix_display)

cat("\n\n**Significance:** *** p<0.001, ** p<0.01, * p<0.05\n")
```

## Results Table: Somers' D (Ordinal Variables Only)

```{r tables_somers_d}
#| echo: false
#| warning: false
#| message: false
#| output: asis


# Create Somers' D comparison matrix (same format as Cram√©r's V)
somers_comparison <- data.frame(
  Demographic = unique(gsub(" √ó .*", "", names(results_somers))),
  stringsAsFactors = FALSE
)

# Add columns for each question
for(q in c("Support Gov't Vaccines (JHU5A)", "Remove School Requirements (JHU6C)")) {
  somers_comparison[[gsub(" \\(.*\\)", "", q)]] <- sapply(somers_comparison$Demographic, function(d) {
    key <- paste0(d, " √ó ", q)
    if(key %in% names(results_somers)) {
      result <- results_somers[[key]]
      if(!is.na(result$somers_d)) {
        sd_str <- sprintf("%.3f", result$somers_d)
        # Add significance stars
        if(!is.na(result$p_value)) {
          if(result$p_value < 0.001) sd_str <- paste0(sd_str, "***")
          else if(result$p_value < 0.01) sd_str <- paste0(sd_str, "**")
          else if(result$p_value < 0.05) sd_str <- paste0(sd_str, "*")
        }
        return(sd_str)
      }
    }
    return("‚Äî")
  })
}

somers_display <- somers_comparison |>
  kable(escape = FALSE, format = "html", row.names = FALSE) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)

print(somers_display)

cat("\n\n**Significance:** *** p<0.001, ** p<0.01, * p<0.05\n")
```

## Statistical Notes

**Standard errors:** Cram√©r's V p-values are derived from the weighted chi-square test via `svychisq()`. Somers' D p-values are calculated using `DescTools::SomersDelta()` which computes asymptotic standard errors accounting for survey weights.

**Caution when comparing associations across groups:** As Gelman and Stern (2006) noted, "the difference between 'significant' and 'not significant' is not itself statistically significant." Just because one demographic shows a significant association (p < 0.05) while another does not, this does not necessarily mean the associations are significantly different from each other. To properly test whether associations differ between groups, one would need to formally test the difference between the coefficients, not simply compare their individual p-values.